[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15236993&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

Questions:
Define Software Engineering:

What is software engineering, and how does it differ from traditional programming?
Software Development Life Cycle (SDLC):

Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.
Agile vs. Waterfall Models:

Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?
Requirements Engineering:

What is requirements engineering? Describe the process and its importance in the software development lifecycle.
Software Design Principles:

Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems?
Testing in Software Engineering:

Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). Why is testing crucial in software development?
Version Control Systems:

What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features.
Software Project Management:

Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects?
Software Maintenance:

Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle?
Ethical Considerations in Software Engineering:

What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?
Submission Guidelines:
Your answers should be well-structured, concise, and to the point.
Provide real-world examples or case studies wherever possible.
Cite any references or sources you use in your answers.
Submit your completed assignment by [due date].

[[!google docs link](https://docs.google.com/document/d/1GWULEaR_OscpRqXbIRVmRRx8SlkY5awf4TEesDU0NmE/edit?usp=sharing)]


Software Engineering 
Software Engineering is a special art that involves designing, building, testing and maintaining software systems. It consists of all the processes involved in the  Software Development Life Cycle, and advocates making a neat system that completely meets the requirements. However, there are several differences between the traditional programming method and software engineering. Below are some of the differences in detail.
Scope: with traditional programming, the programmer’s main focus is on creating a small-scale application that’s unexpandable or that solves a specific problem given the required tools.
Emphasis on the development process: Software engineering demands a keen follow up on the development processes and methodologies to deliver a high-quality system. This includes following standard guidelines and best practices such as the SDLC, to ensure that the software meets the expected quality. 
Focus on quality and maintenance. Software engineering does not just develop the system and leave it at that. It’s more than just creating a system; it goes far and beyond to ensure that the software is always available and reliable. It also maintains the software throughout and ensures scalability whenever possible. 
Software Development Life Cycle
Software DevelopmentLie Cycle is the lifespan of a system from its inception until it is implemented or redesigned. 
There are six phases of SDLC: 
Problem Definition
Preliminary investigation
System Analysis
System Design
Implementation
Maintenance 
Problem Definition 
This is a description of an investigation that has to be figured/carried out and should include what the system does. At this point, a preliminary survey is done to ascertain whether there is need for change in the existing system. If change is necessary, investigation is carried out and terms of reference (ToR)  are drawn.
ToR is a formal document that guides analysts and users of objectives to be used. It consists the following contents: 
Title of the project
Purpose of the study
Project schedule 
Constraints analysts will meet during the study
Subject of study
Professionals involved
Necessary materials to be used
Preliminary Investigation
This involves the system analyst investigating the current system, recording facts and analyzing them with the view of designing a new system. It involves the following:
A feasibility study
Requirement elicitation
System Analysis 
This phase uses the requirements obtained from the requirements elicitation stage to create different models and structures that help the system analyst understand the system requirements.
System analysis is an iterative  process that takes place throughout the development process where data structure avail. 
System Design
This stage involves translation of the requirement specification document into a form that can be incorporated into the system. 
System Implementation
This process involves representing the requirements document into a software product that can be used to carry out the intended tasks. 
Maintenance 
Maintenance makes the software product easy to use and change in order to meet new user end requirements.
Agile Vs. Waterfall Models
The waterfall model, as the name suggests, consists of procedural steps that must be completed from top to bottom. In other terms, waterfall relies on consecutively completing each phase of a project before proceeding to the next phase. 
On the other hand, Agile is more adaptable and flexible as the project can be broken down into small segments and progress can be monitored to match the changing specifications. It is an easy-to-work-with model that allows faster workflows and clear expectations throughout the scope of the project. 
Below is a table showing detailed comparisons of Agile and Waterfall models.

Agile
Waterfall
Agile projects are much quicker than waterfall projects due to a higher level of flexibility.
Waterfall projects often take a longer time, especially in the project planning phase
Documentation is less formal throughout the development process
Each step of the project lifecycle is heavily documents in a formal setting
Cleans and external stakeholders are involved at every step of the way
Clients and external stakeholders are not involved in any project-details until the conclusion
Deliverables and products are turned over throughout the project lifecycle
Deliverables and products are only delivered to stakeholders upon project completion
Planning and structured are highly fluid components that can shift and adjust as evolving situations demand
The project structure is laid out before work begins

 
Both agile and waterfall are good methods of developing a system. However, depending on different scenarios, each method is unique. Waterfall may be preferred when the requirements are well-structured and understood and also are unlikely to change during the project development process. It’s also a good method when there’s a need for extensive documentation and upfront planning. 
Agile, on the other hand, is often best used in cases where requirements are likely to evolve and there is a need for frequent feedback. Its flexibility makes it a good choice for dynamic projects.
Requirements Engineering 
This is one of the most crucial parts in developing a system. It involves analyzing, eliciting, documenting and managing the requirements for a software system. The following are the steps covered during requirements engineering:
Elicitation: Elicitation or information gathering stage involves collection and gathering requirements from various stakeholders, customers, experts, etc. various techniques may be used during this process including, observation, interviews, surveys, and many more.
Analysis: Here is where the collected data is analyzed to ensure it is clear, complete, consistent and feasible. Conflicting or unclear requirements are identified and resolved in this phase. The system analyst may also consider prioritization of requirements based on their importance in the project.
Documentation: Documentation involves user stories, use cases, functional and nonfunctional requirements, system specifications and any other relevant resources. It is a formal document that clearly states the workability and usability of the system.
Validation: Documented requirements are reviewed in a stakeholders meeting to ensure they are accurate and meet the required expectation.
Management: requirements are managed throughout the project to ensure changes,updates and traceability.
Requirement engineering is a crucial stage in system development. Below are some of the advantages:
Quality assurance 
With clear requirements, a project assures quality throughout the development process. This helps make sure the final product meets the quality standard and is good to go.
Cost and Time savings 
Addressing requirements issues early during development is less-costly and time-consuming than addressing them later on.
 Risk management 
Clear requirements help mitigate risks by reducing ambiguity and prevent misunderstandings 
Meeting expectations
Requirements Engineering ensures that the software being designed aligns with the needs of the stakeholders.
Software Design Principles
Modularity refers to the process of creating modules. A module in software engineering means the software components that have been created by dividing the software. Modules work together in an efficient way to meet the objective of a given system. 
Modularity improves maintainability and scalability of software systems in the following ways:
Isolation: By dividing the software and solving issues independently, each module becomes easy to understand, change and develop. 
Encapsulation: Every module has their own internal workings and data. They only expose the necessary interface to interact with the other modules. This encapsulation hides the complexity of the modules, allows easier comprehension and modifications without affecting other parts of the system.
Scalability: Modular programming allows other modules to be added or modified without significant changes to the system. This flexibility allows the system to adapt to changing requirements and accommodate increased workload or functionality over time.
Testing and Debugging: Modular systems are easy to debug because each module has its own functionality. Additionally, modular design utilizes the automated testing frameworks so changes to one module do not introduce regressions in others.
Testing in Software Engineering
Software testing is the process of executing a program with the aim of finding errors. It is an integral part of the software development process as it ensures quality, reliability and performance of the system by mitigating risks associated with software failures and malfunctions. 
There are several types of unit testing:
Unit testing 
This focuses on the smallest units of the system design. Here, someone tests an individual unit of a group of interrelated modules.
Integration testing
Involves a group of components (units)  combined to produce an output. The main focus of the test is to verify communication, data exchange and interoperability between different modules. 
System testing
System testing reveals the behavior of a system after a failure. It tests the system against its requirements to ensure it meets the user expectation. It also guarantees that the system will work properly under regular conditions
Acceptance testing 
Involves validating the software system against the business requirements and user expectations to determine whether it can be implemented in a production environment. 
It is typically carried out by the end-user, stakeholders or quality assurance team to verify the system meets the desired requirements.
Benefits of software testing
Quality assurance 
Testing helps ensure quality, reliability and correctness of software systems by identifying weak points and bugs. 
Risks mitigation
Carrying out tests helps identify potential risks that may affect the system and ensures the issues are addressed before it’s too late.
Compliance
Testing helps make sure that the software complies with the regulatory requirements,industry standards and best practices. 
Customer satisfaction
Testing helps deliver high-quality, reliable and user-friendly software that meets user expectations ensuring satisfaction, loyalty and trust.
Cost savings 
Testing early and frequently helps identify and fix defects when they  are less expensive and time consuming to address, reducing the cost of rework, maintenance and support. 
Version Control Systems
A version control system is a software that helps track changes made in code over time. As the developer edits or makes changes, the version control system takes a snapshot of the files. It then saves the snapshot permanently so it can be visited later if needed. Below are the advantages of the software.
History tracking
Version control systems maintain a complete history of changes to files and directories, including who made the changes and when. 
Backup and disaster recovery
Version control systems serve as a backup mechanism in case anything goes wrong. This may be power interruptions, system failure and more.
 Collaboration
Version control systems enable multiple developers to work on the same codebase concurrently without interfering with each other’s work. 
Code review 
Version control systems support code review processes by providing mechanisms for reviewing changes, commenting on code and discussing proposed modification.
Some of the most popular version control systems include 
Git - includes tools and services such as Github, GitLab and Bitbucket
Subversion (SVN) -  has features such as branching, tagging and merging but it;s less flexible compared to other systems like Git
Mercurial- offers features such as branching, merging, and distributed workflows
Perforce (Helix Core)- offers features such as file storage, branching and access control making it suitable for managing large and complex codebases
Software Project Management 
A software project manager role is to coordinate and oversee all aspects of a software development project, from inception to completion. The key responsibilities include:
Project planning: the project manager is responsible for creating a project plan that outlines the scope, budget, resources and deliverables of the project.
Resource management: the project manager is also responsible for allocation resources, including human resources, equipment, etc. 
Risk management: a project manager assesses and finds ways to mitigate potential risks. They must be thoughtful problem solvers. 
Agent of change: a project manager should be an agent of change, meaning they drive the entire change process and are responsible for ensuring that the changes are acceptable by the parties involved.
Communication and stakeholder management: project managers act as the primary point of contact with stakeholders and communicate the project progress, status and issues effectively and transparently.
Challenges faced in managing software projects
Resource constraints: this involves limited resources, including budget, time, and skilled personnel, which can pose significant challenges in managing software projects. 
Technical complexity: Many software projects often involve complex technical challenges. This may include integration issues, technology dependencies and performance optimization. The project manager must have a very deep understanding of the technical aspects of the project and collaborate effectively with the technical team to address technical-related challenges.
Deadline Pressure: It is crucial to complete the project in the time specified. However, it can sometimes be overwhelming and a lot of work to meet tight deadlines and deliver within a certain schedule. To ensure a smooth run and timely completion, project managers should work collaboratively with the team and communicate effectively to resolve any major conflicts and issues. 
Uncertain requirements: if the requirement engineering phase didn’t quite make certain requirements clear, it can cause misunderstanding and delays of the project. Project managers should ensure that all requirements are effectively revised with the stakeholders and plan on what requirements should be prioritized. 
Scope creep: incorporating changes is one of the most daunting tasks in system development as it affects budget, project timelines and other critical aspects of a project. Project managers should optimize resources and carefully assess scope changes to prevent scope creep.
Software Maintenance
Software maintenance is an SDLC phase that involves updating, modifying, enhancing and managing software after implementation. The main focus of this stage is to address issues, improve functionality and adapt to changing requirements. 
Types of maintenance 
Corrective maintenance: this involves fixing erodes and bugs in the system. 
Adaptive: this type of maintenance involves making modifications to  the software system in order to make it adapt to changes in the environment. 
Preventive maintenance: this involves taking measures to prevent future issues such as optimization, documentation and reviewing.
Perfective: Here, the system is improved for functionality, reliability and performance. 
Patching: patching is done for corrective maintenance but it gives rise to unforeseen future error due to poor analysis. It is an emergency fix implemented mainly due to pressure from the management.
Maintenance is crucial in the software lifecycle for the following reasons:
Maximizing return of investment: effective maintenance prolongs the use of software, which in turn maximizes the return on investment for stakeholders. 
Enhancing software quality: maintenance activities such as bug fixings, performance optimization, etc. help make the system remain relevant and effective. 
Adapting to changing requirements: as business needs, user preferences and technology advances, software must be continuously updated to keep up with the ever-changing environment. Maintenance enables software to evolve alongside these changing conditions. 
Facilitating innovations: maintenance activities such as adding new features and improving user experience help in innovation. Maintenance fosters competitive advantage by bringing ideas to life. 
Ethical Consideration in Software Engineering
The various ethical issues software engineers might encounter include:
Privacy and data Protection
Software engineers may be involved in developing systems that collect, store and process personal data. In that case, they must comply with relevant regulations such as GDPT or HIPAA to ensure the privacy of the data.
Biases 
Algorithms and AI systems developed by software engineers can potentially provide misleading or non-factual information. Additionally the information might be discriminative -based on race, gender, ethnicity or other factors.
Intellectual Property Rights
Software engineers must respect intellectual property rights and avoid unauthorized use of copyrighted materials.
Social Impact 
Software engineers should consider the broader societal impact of their work and strive to develop technologies that promote positive social outcomes and address societal challenges. 
To adhere to ethical standards, software engineers should consider the following proactive measures.
Transparency and accountability
Software engineers should be transparent about the ethical considerations and trade-offs involved in their work. 
Ethical decision-making
Software engineers should consider the ethical implications of their decisions and actions, and seek input from colleagues or stakeholders when faced with ethical dilemmas.
Education 
Software engineers should always be informed about the ethical principle, best practices and relevant laws and regulations through educational programs.
Ethics guidelines and codes of conduct
Software engineers should familiarize themselves with the ethics guidelines and codes of conduct established by professional organizations such as the ACM or IEEE. 
Ethics review and oversight
Seeking guidance and participating in ethics reviews is a good way of staying on path. Engineers can get expert advice, especially if they are working on projects with potential ethical implications.
Resources 
Modularity and its Properties - GeeksforGeeks
Agile vs. Waterfall — from software development to project management (adobe.com)
Agile vs Waterfall Methodology: Differences & How To Choose (project-management.com)
Software Engineering Challenges - Computer Notes (ecomputernotes.com)
Agile vs. Waterfall Methodology – Forbes Advisor
Software Maintenance - Software Engineering - GeeksforGeeks
Ethical Software Development: Impact & Responsibility (coders.dev)
5 examples of ethical issues in software development | TechTarget
What is version control? - Azure DevOps | Microsoft Learn
What is version control? | GitLab


